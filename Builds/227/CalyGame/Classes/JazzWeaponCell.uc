//=============================================================================
// JazzWeaponCell.
//=============================================================================
class JazzWeaponCell expands JazzInventoryItem;

//
// Note for inventory items:  Pickup message is now the item name
//

// Upgradable Weaponry:
//
var 	travel int		CurrentPowerLevel;		// Base power level is 0
var		travel float	CurrentExperience;		// Experience level of item
var() 	int				MaxPowerLevel;			// Maximum power level to stop at
var()	int				ExperienceNeeded[8];	// Experience points needed to go to certain level
var()	string		FireButtonDesc;			// Weapon name for main fire button
var()	string		AltFireButtonDesc;		// Weapon name for secondary fire button
var		byte			Selected;

var		vector			FireOffset;				// Offset vector from player's center for weapon barrel location
var		float			AimError;				// Error in aiming that weapon has

var		JazzShield		ShieldActor;			// Shield Generated by this Cell

// Time until firing is ready.
//
var		float			MainReadyTime;
var		float			MainReadyMax;
var		bool			MainFiring;
var		float			AltReadyTime;
var		float			AltReadyMax;
var		bool			AltFiring;

var		bool			ContinueFire;
var		bool			ContinueAltFire;

// Cell compatibility list.  Determines if a cell can be used with a certain weapon #.
//
// 0 = No
//
var()	byte			WeaponCapable[10];

var		name			ChargeState;
var		class			ChargeEffect;
var		float			ChargeEffectSize;
var		actor			ChargeEffectActor;
var		bool			MainCharging;
var		bool			AltCharging;

//
// Animation Startup
//

function PostBeginPlay()
{
	Super.PostBeginPlay();
	//Log("AnimSeq) "$AnimSequence$" "$AnimRate);
	
	if (Default.AnimSequence != 'None')
	LoopAnim(Default.AnimSequence,1);
}

//
// JAZZ Weapon Experience System
//
// Weapons gain experience from defeating enemies or certain other actions.  Each orb has a different set of
// experience levels it will rise to, requiring varied amounts of experience as well. 
//

///////////////////////////////////////////////////////////////////////////////////////////////
// Weapon Powerup													WEAPON POWERUP
///////////////////////////////////////////////////////////////////////////////////////////////
//
function AddPowerLevel ()
{
	CurrentPowerLevel++;
	if (CurrentPowerLevel>MaxPowerLevel) 
		CurrentPowerLevel = MaxPowerLevel;
}

function int ExperienceNeededNext ()
{
	if (CurrentPowerLevel==MaxPowerLevel)
	return (9999);
	else
	return (ExperienceNeeded[CurrentPowerLevel]);
}

function AddWeaponExperience ( int XP )
{
	CurrentExperience += XP;

	if ((CurrentExperience >= ExperienceNeeded[CurrentPowerLevel]) &&
	    (CurrentPowerLevel < MaxPowerLevel))
	{
		// Level Up
		spawn(class'JazzWeaponLevelUp',Owner);
			
		//CurrentExperience -= ExperienceNeeded[CurrentPowerLevel];
		CurrentPowerLevel++;
		
		// Send event message to player
		JazzPlayer(Owner).DoEvent(1,20,PickupMessage$": LEVEL "$CurrentPowerLevel);
	}
}

//
// Become an inventory item.
//
function NewItemDisplay()
{
	local NewInventoryDisplay	Inv;
	local ParticleColumn 		P;
	
	if (JazzPlayer(Instigator) != None)
	{
	// Has been picked up by a JazzPlayer (Human player)
	
	// Pickup Effect 1		
	P = Spawn(class'ParticleColumn',Instigator);
	P.Activate(0.1,3);

	// Pickup Effect 2
	Inv = spawn(class'NewInventoryDisplay',Instigator);
	Inv.DrawScale = DrawScale;
	Inv.DrawType = DrawType;
	Inv.AmbientGlow = AmbientGlow;
	Inv.AnimSequence = AnimSequence;
	Inv.AnimRate = AnimRate;
	Inv.AnimFrame = AnimFrame;
	Inv.Skin = Skin;
	Inv.Sprite = Sprite;
	Inv.Mesh = Mesh;
	Inv.ItemName = ItemName;
	
	//Inv.SetOwner(Instigator);
	//Inv.bOnlyOwnerSee = true;
	}
	else
	{
	// Has been picked up by a Thinker ('bot')
	bHidden = true;
	}
}

// Main Pickup State
// 
auto state Pickup
{	
	// Validate touch, and if valid trigger event.
	function bool ValidTouch( actor Other )
	{
		local Actor A;
		
		if (JazzPlayer(Other) != None)
		{
			if (JazzHUD(JazzPlayer(Other).myHUD).PreRenderInventory != None)
			{
				// Can't pickup right now - already an actor in the inventory pickup queue
				return false;
			}
		}
		
		if( Pawn(Other)!=None && Level.Game.PickupQuery(Pawn(Other), self) )
		{
			/*if( Event != '' )
				foreach AllActors( class 'Actor', A, Event )
					A.Trigger( Other, Other.Instigator );*/
			return true;
		}
		return false;
	}
}

// Override for specific carrot effect on player/pickupperson as 'Other'
//
// Pickup sound is in (Inventory) section of the actor properties.
//
function PickupFunction( pawn Other )
{
	Selected = 0;
				
	if (Other == None)
	return;
	
	Super.PickupFunction(Other);
		
	if (JazzPlayer(Owner) != None)
	{
		// Update inventory display flag
		JazzPlayer(Owner).NewInventoryItem();
				
		// Tutorial Command
		JazzPlayer(Owner).TutorialCheck(TutorialGetWeaponCell);
	}
	
	Owner.PlaySound(PickupSound);
}

////////////////////////////////////////////////////////////////////////////////////////
// Base function that determines the desirability of an item for a 'bot' (Thinker)
////////////////////////////////////////////////////////////////////////////////////////
//
// See JazzPawnAI for Details
//
function float BotDesireability( pawn Bot )
{
	// Highly desirable if thinker has no weapon and can use them.
	
	if (JazzPawnAI(Bot) != None)
	{
		if ((JazzPawnAI(Bot).CanUseWeapons == true) && (JazzPawnAI(Bot).CanPickupItems == true))
		{
			if (Bot.Weapon == None)		// Has *no* base weapon.  Cannot use cells anyway.
			return (-1);
			else
			if (Bot.FindInventoryType(class) != None)
			return (-1);
			else
			if (JazzPawnAI(Bot).InventorySelections[0]==None)	// Has no special weapon cell - want one highly
			return (80);
			else
			return (40);							// Has a weapon cell already - not as high priority
		}
	}
	return (-1);	// Default Item type is totally undesirable - Override this function to create desirable item
}


///////////////////////////////////////////////////////////////////////////////////////
// Override function for weapon effectiveness rating
//
// JazzPawnAI uses this to determine which weapon and mode to use.
//
// Note:  This function checks on the weapon cell's base attack style.  It's pretty primitive
// in this form and would benefit from a localized redistribution of firing code.
//
// For now we'll just fake it.  Plase note this code is fundamentally sound, but the implementation
// is a temporary measure before more complex ratings are done.  Base rating for all cells is
// '10'.  This ensures a cell will always be chosen over the default weapon.  This isn't 
// necessarily desirable, hence one reason the later rewrite.  I'm amazed if anyone reads this. :)
//
function float	RateCell ()
{
	// Override this function in subclasses
	return (10);
}

function Weapon RecommendWeapon( out float rating, out int bUseAltMode )
{
	local int NewRating;
	local bool AltModeRecommended;
	
	NewRating = RateCell();			// Weapon default has minimum rating
	AltModeRecommended = false;		// Do not recommend alt mode of fire
	
	// New Rating Higher?
	if (Rating < NewRating)
	{
		// Set weapon cell of AI to None	
		//	(WARNING: Bad hack because I do not alter the Engine Inventory class to add new function)
		//
		if (JazzPawnAI(Owner) != None)
		{
			JazzPawnAI(Owner).PerformWeaponCellSelection(Self);
		}
		
		Rating = NewRating;
	}
	
	if ( inventory != None )
		return inventory.RecommendWeapon(rating, bUseAltMode);
	else
	{
		rating = -1;
		return None;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Firing Code																WEAPON
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Weapon cells will now be self-contained firing systems which have all the code necessary to
// perform fire and alt-fire sequences for the various attacks.  Base firing functions that can
// be used for all the cells should be placed here, as well as base functions that are meant to
// be overridden.
//
// Todo: Must check for which weapon is being used and switch to different firing code.	(Owner.Weapon class)
//
//

// Fire projectile
//
function Projectile ProjectileFire(class<projectile> ProjClass, float ProjSpeed, bool bWarn, optional rotator RotateLaunch )
{
	local Vector Start, X,Y,Z, OwnerVel;
	local Projectile da;
	local int OffsetMax;
	local rotator AdjustedAim;
	
	//Log("Projectile Fire) "$Owner$" "$ProjClass$" "$Rotation$" "$Owner.Rotation);

	GetAxes(Pawn(owner).ViewRotation,X,Y,Z);
	
	Start = Owner.Location + /*CalcDrawOffset() +*/ FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z;
	Start.Z += Pawn(Owner).BaseEyeHeight;

	AdjustedAim = pawn(owner).AdjustAim(ProjSpeed, Start, AimError, True, (3.5*FRand()-1<1));
	AdjustedAim.Yaw += (frand()*AimError)-AimError/2;
	AdjustedAim.Pitch += (frand()*AimError)-AimError/2;
	
	Owner.MakeNoise(Pawn(Owner).SoundDampening);
	
	da = Spawn(ProjClass,,,Start,AdjustedAim+RotateLaunch);
	return da;
}

// Create Player shield effect
//
function Projectile ShieldEffect (class<projectile> ProjClass)
{
	local Projectile P;
	
	if (JazzPlayer(Owner) != None)	// Player
	{
		if (JazzPlayer(Owner).ShieldActor.Class != ProjClass)	// No current shield
			RemoveShieldActor();
		
		if (ShieldActor == None)
		{
		P = Spawn(ProjClass,Owner);
		//Log("NewShield) "$ProjClass$" "$P);
		JazzPlayer(Owner).ShieldActor = JazzShield(P);
		ShieldActor = JazzShield(P);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Base function to detect the weapon in use.  Each weapon is given a # corresponding to its type.
//
// No weapon ......	0	: None
// Jazz's weapon .. 1	: Inventory.Weapon.JazzWeapon.JackrabbitGun
// Spaz's weapon .. 2	: Not implemented yet
// Eva's weapon ... 3	: Not implemented yet
// Lori's weapon .. 4	: Not implemented yet
// 
//
function int DetectWeapon()
{
	if (Pawn(Owner).Weapon == None)
	return (0);
	else
	return (JazzWeapon(Pawn(Owner).Weapon).WeaponTypeNumber);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Continue weapon firing
//
function CheckContinueFire ()
{
	GotoState('Idle');
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Function called when player has first pressed fire.
//
function Fire( float Value )	// Change DoFire instead
{
	if (MainReadyTime<=0)		// Alt fire ready?
	{
		// Weapon is being fired
		Pawn(Owner).Weapon.bPointing = true;
		
		//Log("Cell Fired) "$Self);
		switch (DetectWeapon())		// Detect weapon # in use
		{
		case 0:	// Default
		case 1:	// Jazz's Weapon
			GotoState('FireStateJazz');
		break;
		case 2: // Missile Launcher
			GotoState('FireStateJazz','Missile');
		break;
		case 5: // Shiv
			GotoState('FireStateJazz','Gizmo');
		break;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Function called when player has first pressed alt-fire.
//
function AltFire( float Value )	// Change DoAltFire
{
	if (AltReadyTime<=0)		// Main fire ready?
	{
		// Weapon is being fired
		Pawn(Owner).Weapon.bPointing = true;
		
		switch (DetectWeapon())		// Detect weapon # in use
		{
		case 0:	// Default
		case 1:	// Jazz's Weapon
			GotoState('AltFireStateJazz');
		break;
		case 2: // Missile Launcher
			GotoState('FireStateJazz','Missile');
		break;
		case 5: // Shiv
			GotoState('FireStateJazz','Gizmo');
		break;
		}
	}
}

// State when fire is active with no base weapon type
//
state FireStateJazz			// Jazz Jackrabbit's Weapon
{
ignores Fire,AltFire;		// Ignore Fire or AltFire commands while currently firing.

function BeginState()
{
	MainFiring = true;
}

function EndState()
{
	MainFiring = false;
	ContinueFire = true;
}

function Tick ( float DeltaTime )
{
	if (MainCharging)
	{
		if ( JazzPlayer(Owner).bFire==0 ) 	
		if (ChargeState != '')
		{
		MainCharging = false;
		GotoState('FireStateJazz',ChargeState);
		}
	}
	
	Super.Tick(DeltaTime);
}

Shiv:		// Electro Shiv
	// Perform actual firing here
	
	// Return to idle state after fire sequence is done and button not held down.
	CheckContinueFire();

Begin:
	// Perform actual firing here
	
	// Return to idle state after fire sequence is done and button not held down.
	CheckContinueFire();
}

// State when fire is active
//
state AltFireStateJazz		// Jazz Jackrabbit's Weapon
{
ignores Fire,AltFire;		// Ignore Fire or AltFire commands while currently firing.

function BeginState()
{
	AltFiring = true;
}

function EndState()
{
	AltFiring = false;
	ContinueAltFire = true;
}

function Tick ( float DeltaTime )
{
	if (AltCharging)
	{	
		if (( JazzPlayer(Owner).bAltFire==0 )) 	
		if (ChargeState != '')
		{
		AltCharging = false;
		GotoState('AltFireStateJazz',ChargeState);
		}
	}

	Super.Tick(DeltaTime);
}

Shiv:		// Electro Shiv
	// Perform actual firing here
	
	// Return to idle state after fire sequence is done and button not held down.
	CheckContinueFire();

Begin:		// Default Weapon (Jazz's Weapon)
	// Perform actual firing here
	
	// Return to idle state after fire sequence is done and button not held down.
	CheckContinueFire();
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// State when inactive
///////////////////////////////////////////////////////////////////////////////////////////////////
//
state Idle
{
Begin:
	//Pawn(Owner).Weapon.bPointing = false;
	Selected = 0;
	ChargeEnd();
	
}



///////////////////////////////////////////////////////////////////////////////////////////////////
// Weapon Select / Deselect
///////////////////////////////////////////////////////////////////////////////////////////////////
//
function SelectWeapon()
{
	// Todo: Add Delay Until Fire
	//Log("JazzWeaponCell) Selected");
	ChargeEnd();
	Selected = 2;
	if (MainReadyTime<0.05)	MainReadyTime = 0.05;
	if (AltReadyTime<0.05) AltReadyTime = 0.05;
}

function DeSelectWeapon()
{
	// Shut down all weapon firing and weapon repeat firing functions.
	Selected = 1;
	MainFiring = false;
	AltFiring = false;
	ContinueFire = false;
	ContinueAltFire = false;
	RemoveShieldActor();
	ChargeEnd();
	
	GotoState('Idle');
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// AltFire
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Override this function to tell when the weapon has Alt-Fire capability.
// (For different player base weapons, for different experience levels, etc.)
//
function bool	HasAltFire()
{
	/* 
	// Example function
	//
	switch (DetectWeapon())		// Detect weapon # in use
	{
	case 0:	// Default
	case 1:	// Jazz's Weapon
		if (CurrentPowerLevel >= 1)
		return(true);
	break;
	}
	
	return(false);
	*/
	
	return (false);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Weapon Reload Timings
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Call this function to add a delay for the main fire mode reloading.
//
function MainFireDelay( float Time )
{
	MainReadyMax = Time;
	MainReadyTime = Time;
	MainFiring = false;
	//Pawn(Owner).Weapon.bPointing = false;
}

// Call this function to add a delay for the alt fire mode reloading
//
function AltFireDelay( float Time )
{
	AltReadyMax = Time;
	AltReadyTime = Time;
	AltFiring = false;
}

// Returns percentage of ready status
//
function float MainReadyPct ()
{
	if (MainReadyMax<=0)	// Never been used
	return(1);
	else
	if (MainFiring==true)	// Currently still firing
	return(0);
	else
	return(1-(MainReadyTime / MainReadyMax));	// Current ready status
}

// Returns percentage of ready status
//
function float AltReadyPct ()
{
	if (HasAltFire()==false)		// Change to a boolean which is altered infrequently?
	return(-1);
	else
	if (AltReadyMax<=0)		// Never been used
	return(1);
	else
	if (AltFiring==true)	// Currently still firing
	return(0);
	else
	return(1-(AltReadyTime / AltReadyMax));	// Current ready status
}

event Tick ( float DeltaTime )
{
	Super.Tick(DeltaTime);

	// Ready Times
	MainReadyTime = MainReadyTime - DeltaTime;
	if (MainReadyTime<0) MainReadyTime = 0;
	
	// Ready Times
	AltReadyTime = AltReadyTime - DeltaTime;
	if (AltReadyTime<0) AltReadyTime = 0;

	// Check for continued firing
	//	
	if (Selected>0)
	{
		ContinueFire = false;
		ContinueAltFire = false;
		Selected -= 1;	
		return;
	}
	else
	if (JazzPlayer(Owner) != None)
	{
		if (ContinueFire)
		if (MainReadyTime<=0)
		if (( JazzPlayer(Owner).bFire!=0 )) 	
		{ 
		Fire(0); return;
		}
		else
		ContinueFire = false;
				
		if (ContinueAltFire)
		if (AltReadyTime<=0)
		if (( JazzPlayer(Owner).bAltFire!=0 ))
		{
		AltFire(0); return;
		}
		else
		{
		ContinueAltFire = false;
		RemoveShieldActor();
		}

		// Weapon is being fired
		//if ((ContinueFire==false) && (ContinueAltFire==false))
		if 	(( JazzPlayer(Owner).bAltFire==0 ) &&
			( JazzPlayer(Owner).bFire==0 ))
		{
		if (Pawn(Owner) != None)
		Pawn(Owner).Weapon.bPointing = false;
		}
	}
	
	ChargeEnd();
}

function RemoveShieldActor()
{
	if (ShieldActor != None)
	{
	ShieldActor.ShieldDie();
	ShieldActor = None;
	}
	
	if (JazzPlayer(Owner) != None)
	{
		if (JazzPlayer(Owner).ShieldActor != None)
		JazzPlayer(Owner).ShieldActor.ShieldDie();
	}
}

// Weapon Charge Functions
//
function ChargeStart( name LChargeState, class LChargeEffect, bool bAltFire, float LChargeEffectSize, optional float ScalePeriod, optional float ScaleTarget )
{
	Log("ChargeStart) "$LChargeState$" "$LChargeEffect$" "$bAltFire);

	if (bAltFire)
	{
	AltCharging = true;
	}
	else
	{
	MainCharging = true;
	}
	
	ChargeState = LChargeState;
	ChargeEffect = LChargeEffect;
	ChargeEffectSize = LChargeEffectSize;
	if (ChargeEffectActor == None)
	{
	ChargeEffectActor = spawn(class<actor>(LChargeEffect),Owner);
	}
	
	if (ChargeEffectActor != None)
	{
	ChargeEffectActor.DrawScale = LChargeEffectSize;
	JazzChargingEffects(ChargeEffectActor).InitialScale = LChargeEffectSize;
	JazzChargingEffects(ChargeEffectActor).TargetScale = ScaleTarget;
	JazzChargingEffects(ChargeEffectActor).ScalePeriod = ScalePeriod;
	JazzChargingEffects(ChargeEffectActor).ScaleTimer = 0;
	}
}

function ChargeEnd ()
{
	MainCharging = false;
	AltCharging = false;
	
	if (ChargeEffectActor != None)
	{
	ChargeEffectActor.GotoState('Die');
	ChargeEffectActor.Destroy();
	ChargeEffectActor = None;
	}
}

function AnimateWeapon( int Animation )
{
	JazzWeapon(Pawn(Owner).Weapon).WeaponAnimationNormal();
}

// Make sure no unwarranted animations are being called
function AnimEnd()
{
}

// Ammo Usage
//
// Check if enough 'ammo' exists to use this weapon.
function bool CheckAvailableAmmo( float Amount )
{
	if (JazzPlayer(Owner) != None)
	return(JazzPlayer(Owner).ManaAmmo >= Amount);
}

// Reduce ammo by this amount.
function UseAmmo( float Amount )
{
	JazzPlayer(Owner).ManaAmmo -= Amount;
}

defaultproperties
{
     InventoryGroup=10
     RespawnTime=30.000000
     PickupViewMesh=Mesh'JazzObjectoids.wcell'
     PickupSound=Sound'JazzSounds.Items.item2'
     Mesh=Mesh'JazzObjectoids.wcell'
     SoundRadius=50
     SoundVolume=255
     AmbientSound=Sound'JazzSounds.Items.Dreamcel'
}
